PUC-Minas - ICEI - Ciência da Computação
Algoritmos e Estruturas de Dados I - Aula 2023-2_002
Anotações
___

Desenvolvimento baseado em testes ("Test-Driven Development")

          análise             síntese
problema --------> algoritmo --------> solução
    ^                  ^                  |  teste
    |                  |                  v          
    +<-----------------+<-----------------+


Desenvolvimento progressivo (P-A-S-T)
    
                        ^
         planejamento   |     análise 
                +------>|-------+      
 acréscimo de   |       |       |
 conhecimento   |   +-->|-->+   |
           |<-->|   |   |   |   |
        <--| ---|---+<--+-------|------->
           ^    |       |   |   |
           |    +<------|<--+   |
           |            |       |
           +<-----------|<------+
              teste     |     síntese

___

Resumo da semana

Fases de um algoritmo / programa

 Problema  ->       Solução      ->  Resposta
    |  especificar     |  descrever     |  apresentar
    v                  v                v
 Entradas  ->     Processamento  ->   Saídas
    |  estudar         |  analisar      |  verificar
    v                  v                v
  dados    +         ações       =   resultados
(externos)         (externas)        (externos)
    |  codificar       |  programar     ^  testar
    v                  v                |
 valores   +       instruções    =    valores
(internos)         (internas)        (internos)
    |                  |                ^      
    |  guardar         v  carregar      |  converter
    +-------->   Armazenamento  --------+ 
    
___

Modelo
                               dados
                             converter
 _________      _______________      ____________
|         |    |               |    |            |
|         |<===|   Entradas    |<===|            |
|         |    |_______________|    |            |
|         |          operar         |            |
|         |     _______________     |            |
|         |    |               |    | Interfaces |
| Memória |<==>| Processamento |    |    com     |
|         |    |_______________|    |  Ambiente  |
|         |guardar                  |            |
|         |     _______________     |            |
|         |    |               |    |            |
|         |===>|     Saídas    |===>|            |
|_________|    |_______________|    |____________|
                             converter
                             resultados

___

1. Dados

Representações de dados

          interpretação
              char
               'A'
              /   \
             /     \
            /       \
representação ----- objeto/dado
     int               binário
      65              0100 0001

Principais tipos de dados

bool		para valores lógicos {false, true}

char		para caracteres (símbolos, letras, dígitos)

short		para valores inteiros "curtos"
int	        para valores inteiros "comuns"
long		para valores inteiros "longos"

float		para valores reais de precisão simples
double		para valores reais de precisão dupla

                   Tipos   de    dados
                         em  C/C++	
							
                          número
                            |			
	           _____________|_________
	          |                       |
           inteiro             ponto flutuante	
              |                       |
 _____________|____________      _____|______				
|       |     |     |	   |    |            |
bool  short  int   long  char float       double
							

C/C++ - Detalhes sobre as representações de dados

Tipos           	Formatos            	Intervalo	     Tamanho
           ____
bool	  |____|	                     [ false:true ]	       1 byte
0, false													
           ____              ____ ____
char	  |____|	wchar   |____|____|  [ 0 : 255 ]           1 byte
'0','\0'          '\u0000'               [ 0 : 65535 ]         2 bytes
           _________
short     |_|_______|	                 [ -32768 : 32767 ]    2 bytes
0	   ±	a					         (sinal+amplitude)	
           ________________                  31   31
int       |_|______________|             [ -2  : 2  -1 ]       4 bytes
0          ±	a	                    (sinal+amplitude)	   (32 bits)
           ______________________            63   63
long long |_|____________________|       [ -2  : 2  -1 ]	   8 bytes
0L         ±	a			            (sinal+amplitude)	   (64 bits)
           ________________                     -38      +38
float	  |_|____|_________|	         [ -1.1e   : 3.4e   ]  4 bytes
0.0f       ±  e=8     1.m   IEEE754 (sinal*2(e-127)*1.mantissa)(32 bits)
           ______________________            -308       +308
double	  |_|______|_____________|	   [-2.2e     : 1.7e    ]  8 bytes
0.0        ±   e       .mantissa	     (precisão dupla)	   (64 bits)

char[ ]    ___________________________ 
ou char*  |____|____|___ ... ___|_____|			                 n bytes
"", "0",   [0]	[1]              [n-1]
NULL, nullptr									

___

Valores e variáveis

- valor    (val) -> conteúdo imutável
   
  Exemplos:
     
      0  -> falso               , lógico
      
            a afirmativa: (0 é igual a 1) -> resultado = 0 (falso)
            a afirmativa: (0 é igual a 0) -> resultado = 1 (verdadeiro)
            
            {false=0, true=1}
            
      0  -> valor numérico  zero, inteiro
      
            ..., -1, 0, +1, ...
            
            {INT_MIN, ..., 0, ..., INT_MAX}
            
     0.0 -> valor numérico  zero, real

            ..., -1.0, ..., -0.5, ..., 0.0, ..., +0.1, ..., +1.0, ...
            
            {REAL_MIN, ..., 0.0, REAL_MAX}

     '0' -> valor simbólico zero, caractere    (unidade)
     
            {'0':'9'} - algarismos/dígitos
            {'A':'Z'} - letras maiúsculas
            {'a':'z'} - letras minúsculas
            
            '0'   -> código = 48 = 0030 hexadecimal = 3*16+0 
            'A'   -> código = 65 = 0041 hexadecimal = 4*16+1
            'a'   -> código = 97 = 0061 hexadecimal = 6*16+1
            
     "0" -> valor simbólico zero, caractere(s) ( grupo = "string" )
     
            ""    -> {}                 grupo vazio
                     ['\0']             representação interna
            "0"   -> {'0'}              grupo unitário
                     ['0','\0']
            "00"  -> {'0','0'}          grupo com mais de um elemento
                     ['0','0','\0']
            "000" -> {'0','0','0'}      grupo com mais de um elemento
                     ['0','0','0','\0']
     
            NOTA: Na linguagem C o grupo encerra-se no caractere '\0'.
                  Na linguagem C++ não há necessidade de encerramento.

- variável (var) -> conteúdo mutável (caixa, "container", "box")

             _______________
            |               |
            |     valor     |
            |_______________|
            ^               ^
            |               |
     endereço <- tamanho -> endereço
     inicial                final

     variável ::= { tipo, nome, endereço, tamanho, formato, valor, ... }

                 Memória
             _______________  nnnn = endereço final  
            |               |
            |--           --|
            |      ...      |
            |--           --|
            |_______________|
            |               |
          3 |_______________| 0011 = endereço final   de variável
            |               | ^
          2 |_______________| |      tamanho 
            |               | |      (4 bytes)
          1 |_______________| |      (1 byte = 8 bits)
            | | | | | | | | | v
          0 |_|_|_|_|_|_|_|_| 0008 = endereço inicial de variável
            |               |
            |--    ...    --|
            |_______________| 0000 =  endereço inicial
            
___
            
2. Estruturas de controle

2.1 Sequência
     
{ // inicio do bloco
  acao1( ); acao2( );
  acao3( );
} // fim    do bloco

            
2.2 Alternativas

2.2.1 Alternativa simples

if ( teste )
{ // verdadeiro
  acao1( ); acao2( );
  acao3( );
} // fim    do bloco
acao4( );

2.2.2 Alternativa dupla
            
if ( teste )
{ // verdadeiro
  acao1( ); acao2( );
  acao3( );
} // fim    do bloco
else
{ // falso
  acao4( ); 
  acao5( );
} // fim    do bloco
acao6( );

2.2.3 Alternativa múltipla
            
switch ( opcao )
{ // se opcao for igual a ...
  case 0:
    acao1( ); acao2( );
    acao3( );
   break;
  case 1:
    acao4( );
   break;
  case 2:
    acao5( );
   break;
  default:
    acao6( );
   break;
} // fim    do bloco
acao7( );

ou

if ( opcao == 0 )
{ // se opcao for igual a ...
    acao1( ); acao2( );
    acao3( );
}
else
{
  if ( opcao == 1 )
  {
     acao4( );
  }  
  else
  {
     if ( opcao == 2 )
     { 
         acao5( );
     }
     else
     { // default:
         acao6( );
     }
  }   
} // fim    do bloco
acao7( );

2.3 Repetições

2.3.1 Repetição com teste no início

acao1( );   // inicio
// testar antes de fazer (preventiva)
while ( teste ) 
{
  acao2( ); acao3( );
  acao4( ); // variacao
} // fim    do bloco

2.3.2 Repetição com teste no início e variação

// testar antes de fazer (preventiva)
for ( inicio; teste; variacao )
{
  acao2( ); acao3( );
  acao4( ); // variacao
} // fim    do bloco

2.3.3 Repetição com teste no fim

acao1( );   // inicio
// testar depois de fazer (corretiva)
do
{
  acao2( ); acao3( );
  acao4( ); // variacao
}
while ( teste );

___

3. Abstrações de comandos

3.1 Função

// definicao
tipo f ( parametros )
{
  tipo emissor = padrao;
  
  acao1( );
  acao2( ); acao3( );
  
  return ( emissor ); 
} // fim funcao f ( )
    
// uso
...
{
   tipo receptor = inicial;
   
   acao1( );
   receptor = f ( x ); // chamada
   acao2( );   
}

3.2 Procedimento

// definicao
void p ( parametros )
{
  acao1( );
  acao2( ); acao3( );
} // fim procedimento p ( )

// uso
...
{
   acao1( );
   p  ( x ); // chamada
   acao2( );   
}

___

4. Entradas e saídas

Biblioteca io.h / io.hpp

// entradas de dados
bool   b_x = IO_readbool   ( "b_x = " );
char   c_x = IO_readchar   ( "c_x = " );
int    i_x = IO_readint    ( "i_x = " );
double d_x = IO_readdouble ( "d_x = " );

// saidas de mensagens/resultados
IO_print   ( texto ); // nao muda de linha
IO_println ( texto ); //     muda de linha

// saidas de mensagens/resultados formatadas
IO_printf  ( "formato", valor ); 
IO_printf  ( "%d" , b_x ); // %d -> decimal
IO_printf  ( "%c" , c_x ); // %c -> caractere
IO_printf  ( "%i" , i_x ); // %i -> inteiro
IO_printf  ( "%lf", d_x ); // %lf-> real
IO_printf  ( "%s" , "mensagem" ); 
IO_printf  ( "\n" ); // mudar de linha 
IO_printf  ( "\t" ); // tabular 

___

Resumo de comandos de sistema

Windows  Linux
cmd      terminal      - abrir janela de comandos ( prompt )
         (bash)

dir      dir
         ls
         ls -l         - mostrar conteúdos (pasta | arquivos)

         mkdir aed1    - criar pasta
         ls

         cd aed1       - entrar na pasta
         cd ..         - voltar  à pasta anterior
         cd ./aed1     - entrar na pasta (novamente)
		 cd /          - ir      à pasta raiz
		 cd ~          - voltar  à pasta do usuário
         
                       - criar arquivo para programa
         touch programa.cpp
                                                    
                       - renomear arquivo
         mv programa.cpp  renomeado.cpp

                       - copiar arquivo     
         cp renomeado.cpp copia.cpp
